"use strict";(self.webpackChunkmui_treasury=self.webpackChunkmui_treasury||[]).push([[5330],{"./node_modules/@mdx-js/react/lib/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Z:()=>MDXProvider,a:()=>useMDXComponents});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js");const emptyComponents={},MDXContext=react__WEBPACK_IMPORTED_MODULE_0__.createContext(emptyComponents);function useMDXComponents(components){const contextComponents=react__WEBPACK_IMPORTED_MODULE_0__.useContext(MDXContext);return react__WEBPACK_IMPORTED_MODULE_0__.useMemo((function(){return"function"==typeof components?components(contextComponents):{...contextComponents,...components}}),[contextComponents,components])}function MDXProvider(properties){let allComponents;return allComponents=properties.disableParentContext?"function"==typeof properties.components?properties.components(emptyComponents):properties.components||emptyComponents:useMDXComponents(properties.components),react__WEBPACK_IMPORTED_MODULE_0__.createElement(MDXContext.Provider,{value:allComponents},properties.children)}},"./blocks/use-number-input/usage.mdx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{default:()=>MDXContent});__webpack_require__("./node_modules/react/index.js");var jsx_runtime=__webpack_require__("./node_modules/react/jsx-runtime.js"),lib=__webpack_require__("./node_modules/@mdx-js/react/lib/index.js"),dist=__webpack_require__("./node_modules/@storybook/blocks/dist/index.mjs");const useNumberInputraw_namespaceObject='import { useEffect, useRef, useState } from "react";\nimport { useSpinner } from "./useSpinner";\n/**\n * Get the normalized event key across all browsers\n * @param event keyboard event\n */\nfunction normalizeEventKey(event) {\n  const {\n    key,\n    keyCode\n  } = event;\n  const isArrowKey = keyCode >= 37 && keyCode <= 40 && key.indexOf("Arrow") !== 0;\n  const eventKey = isArrowKey ? `Arrow${key}` : key;\n  return eventKey;\n}\nexport const minSafeInteger = Number.MIN_SAFE_INTEGER || -9007199254740991;\nexport const maxSafeInteger = Number.MAX_SAFE_INTEGER || 9007199254740991;\nexport const toNumber = value => {\n  if (value === "") return undefined;\n  const result = Number(value);\n  return Number.isNaN(result) ? undefined : result;\n};\nexport const numberToString = (value, precision = 0) => {\n  const result = value?.toFixed(precision) ?? "";\n  if (result === "NaN") return "";\n  return result;\n};\nexport const getStepFactor = (event, step, precision) => {\n  let ratio = 1;\n  if (event.metaKey || event.ctrlKey) {\n    ratio = 0.1;\n  }\n  if (event.shiftKey) {\n    ratio = 10;\n  }\n  let stepFactor = ratio * step;\n  if (stepFactor < 1 / Math.pow(10, precision)) {\n    stepFactor = step;\n  }\n  return stepFactor;\n};\nconst noop = value => value;\nexport const useNumberBoundary = (options = {}) => {\n  const {\n    min = minSafeInteger,\n    max = maxSafeInteger,\n    defaultValue,\n    value,\n    precision = 0,\n    step = 1,\n    keepWithinRange = true,\n    formatter = noop,\n    parser = noop\n  } = options;\n  const [interfaceValue, setInterfaceValue] = useState(formatter(numberToString(defaultValue, precision)));\n  const numberValue = toNumber(parser(interfaceValue));\n  useEffect(() => {\n    if (defaultValue === undefined && value !== numberValue) {\n      setInterfaceValue(formatter(numberToString(value, precision)));\n    }\n  }, [value]);\n  function change(multiplier = 1, params = {}) {\n    setInterfaceValue(current => {\n      const result = (toNumber(parser(current)) ?? 0) + multiplier * (params.step ?? step);\n      const digits = params.precision ?? precision;\n      if (keepWithinRange) {\n        if (result > max) return max.toFixed(digits);\n        if (result < min) return min.toFixed(digits);\n      }\n      return formatter(result.toFixed(digits));\n    });\n  }\n  function increment(params = {}) {\n    change(1, params);\n  }\n  function decrement(params = {}) {\n    change(-1, params);\n  }\n  return {\n    numberValue,\n    interfaceValue,\n    setInterfaceValue: value => {\n      setInterfaceValue(formatter(value));\n    },\n    increment,\n    decrement\n  };\n};\nfunction callAllHandlers(...handlers) {\n  return event => {\n    handlers.forEach(handler => {\n      if (typeof handler === "function") {\n        handler(event);\n      }\n    });\n  };\n}\nconst useIsFirstMount = () => {\n  const isFirstMount = useRef(true);\n  useEffect(() => {\n    isFirstMount.current = false;\n  }, []);\n  return isFirstMount.current;\n};\nfunction getError(value, min, max) {\n  if (typeof value === "number") {\n    if (value < min) return "below-min";\n    if (value > max) return "exceed-max";\n  }\n  return null;\n}\nexport const useNumberInput = (options = {}) => {\n  const inputRef = useRef(null);\n  const {\n    min = minSafeInteger,\n    max = maxSafeInteger,\n    step = 1,\n    precision = 0,\n    focusInputOnChange = true,\n    keepWithinRange = true,\n    clampValueOnBlur = true,\n    allowMouseWheel = false,\n    parser = noop,\n    formatter = noop,\n    onChange\n  } = options;\n  const {\n    interfaceValue,\n    setInterfaceValue,\n    numberValue,\n    increment,\n    decrement\n  } = useNumberBoundary(options);\n  useEffect(() => {\n    if (process.env.NODE_ENV !== "production") {\n      if (focusInputOnChange && !inputRef.current) {\n        console.warn(`Cannot find inputRef, make sure to pass it to <input /> like this ðŸ‘‡\n\nfunction NumberInput() {\n  const { inputRef } = useNumberInput(options)\n  return (\n    <input ref={inputRef} />\n  )\n}\n        `);\n      }\n    }\n    function handler(event) {\n      const isInputFocused = document.activeElement === inputRef.current;\n      if (!allowMouseWheel || !isInputFocused) return;\n      event.preventDefault();\n      const stepFactor = getStepFactor(event, step, precision);\n      const direction = Math.sign(event.deltaY);\n      if (direction === -1) {\n        increment({\n          step: stepFactor\n        });\n      } else if (direction === 1) {\n        decrement({\n          step: stepFactor\n        });\n      }\n    }\n    document.addEventListener("wheel", handler);\n    return () => {\n      document.removeEventListener("wheel", handler);\n    };\n  }, [inputRef.current]);\n  const isFirstMount = useIsFirstMount();\n  useEffect(() => {\n    if (!isFirstMount) {\n      onChange?.(numberValue, {\n        valueText: interfaceValue,\n        error: getError(numberValue, min, max),\n        eventType: "change"\n      });\n    }\n  }, [interfaceValue]);\n  const tempInterfaceValue = useRef(interfaceValue);\n  const spinner = useSpinner(increment, decrement);\n  const spinUp = event => {\n    event.preventDefault();\n    spinner.up({\n      step: getStepFactor(event, step, precision)\n    });\n    if (focusInputOnChange) inputRef.current?.focus();\n  };\n  const spinDown = event => {\n    event.preventDefault();\n    spinner.down({\n      step: getStepFactor(event, step, precision)\n    });\n    if (focusInputOnChange) inputRef.current?.focus();\n  };\n  const handleKeyDown = event => {\n    const stepFactor = getStepFactor(event, step, precision);\n    const keyMap = {\n      ArrowUp: () => increment({\n        step: stepFactor\n      }),\n      ArrowDown: () => decrement({\n        step: stepFactor\n      })\n    };\n    const eventKey = normalizeEventKey(event);\n    const action = keyMap[eventKey];\n    if (action) {\n      event.preventDefault();\n      action(event);\n    }\n  };\n  const handleChange = event => {\n    tempInterfaceValue.current = interfaceValue;\n    const result = parser(event.target.value);\n    if (result.match(/^(-|\\+)?(0|[1-9]\\d*)?(\\.)?(\\d+)?$/)) {\n      setInterfaceValue(result);\n    }\n  };\n  const handleBlur = event => {\n    const parsedValue = parser(event.target.value);\n    if (parsedValue !== "") {\n      const nextNum = Number(parsedValue);\n      let result = "";\n      if (Number.isNaN(nextNum)) {\n        result = tempInterfaceValue.current;\n      } else {\n        result = nextNum.toFixed(precision);\n        if (clampValueOnBlur) {\n          if (nextNum > max) result = max.toFixed(precision);\n          if (nextNum < min) result = min.toFixed(precision);\n        }\n      }\n      setInterfaceValue(result);\n      onChange?.(Number(result), {\n        valueText: formatter(result),\n        error: getError(Number(result), min, max),\n        eventType: "blur"\n      });\n    } else {\n      onChange?.(undefined, {\n        valueText: "",\n        error: null,\n        eventType: "blur"\n      });\n    }\n  };\n  const incrementDisabled = keepWithinRange && typeof numberValue === "number" && numberValue >= max;\n  const decrementDisabled = keepWithinRange && typeof numberValue === "number" && numberValue <= min;\n  return {\n    inputRef,\n    getInputProps: handlers => ({\n      pattern: "[0-9]*(.[0-9]+)?",\n      role: "spinbutton",\n      "aria-valuemin": min,\n      "aria-valuemax": max,\n      autoComplete: "off",\n      autoCorrect: "off",\n      "aria-valuetext": interfaceValue,\n      "aria-valuenow": numberValue,\n      value: interfaceValue,\n      onChange: handleChange,\n      onBlur: callAllHandlers(handleBlur, handlers?.onBlur),\n      onKeyDown: callAllHandlers(handleKeyDown, handlers?.onKeyDown)\n    }),\n    getIncrementProps: handlers => ({\n      tabIndex: -1,\n      ...(typeof window !== "undefined" && !!document.documentElement.ontouchstart ? {\n        onTouchStart: callAllHandlers(spinUp, handlers?.onTouchStart)\n      } : {\n        onMouseDown: callAllHandlers(spinUp, handlers?.onMouseDown)\n      }),\n      onMouseUp: callAllHandlers(spinner.stop, handlers?.onMouseUp),\n      onMouseLeave: callAllHandlers(spinner.stop, handlers?.onMouseLeave),\n      onTouchEnd: callAllHandlers(spinner.stop, handlers?.onTouchEnd),\n      disabled: incrementDisabled,\n      "aria-disabled": incrementDisabled ? true : undefined\n    }),\n    getDecrementProps: handlers => ({\n      tabIndex: -1,\n      ...(typeof window !== "undefined" && !!document.documentElement.ontouchstart ? {\n        onTouchStart: callAllHandlers(spinDown, handlers?.onTouchStart)\n      } : {\n        onMouseDown: callAllHandlers(spinDown, handlers?.onMouseDown)\n      }),\n      onMouseUp: callAllHandlers(spinner.stop, handlers?.onMouseUp),\n      onMouseLeave: callAllHandlers(spinner.stop, handlers?.onMouseLeave),\n      onTouchEnd: callAllHandlers(spinner.stop, handlers?.onTouchEnd),\n      disabled: decrementDisabled,\n      "aria-disabled": decrementDisabled ? true : undefined\n    })\n  };\n};';function _createMdxContent(props){const _components={code:"code",h2:"h2",pre:"pre",...(0,lib.a)(),...props.components};return(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsx)(dist.h_,{title:"Hook/useNumberInput"}),"\n",(0,jsx_runtime.jsx)(_components.h2,{id:"cli",children:"CLI"}),"\n",(0,jsx_runtime.jsx)(_components.pre,{children:(0,jsx_runtime.jsx)(_components.code,{className:"language-sh",children:"npx mui-treasury@latest clone use-number-input\n"})}),"\n",(0,jsx_runtime.jsx)(_components.h2,{id:"usenumberinput",children:"UseNumberInput"}),"\n",(0,jsx_runtime.jsx)(dist.Hw,{code:useNumberInputraw_namespaceObject,language:"tsx"})]})}function MDXContent(props={}){const{wrapper:MDXLayout}={...(0,lib.a)(),...props.components};return MDXLayout?(0,jsx_runtime.jsx)(MDXLayout,{...props,children:(0,jsx_runtime.jsx)(_createMdxContent,{...props})}):_createMdxContent(props)}}}]);